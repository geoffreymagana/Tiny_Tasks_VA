
import { z } from 'zod';

// ----- Data Structures -----
export const InvoiceItemSchema = z.object({
  id: z.string().optional(), // For client-side keying if needed, not strictly for Firestore subcollection items
  description: z.string().min(1, "Item description is required.").max(200, "Description too long."),
  quantity: z.number().min(0.01, "Quantity must be greater than 0.").max(10000, "Quantity too large."),
  unitPrice: z.number().min(0, "Unit price cannot be negative.").max(1000000, "Unit price too large."),
  // total will be calculated: quantity * unitPrice
});
export type InvoiceItem = z.infer<typeof InvoiceItemSchema>;

export const InvoiceStatusSchema = z.enum(['draft', 'pending', 'paid', 'overdue', 'void']);
export type InvoiceStatus = z.infer<typeof InvoiceStatusSchema>;

export const InvoiceSchema = z.object({
  id: z.string().optional(), // Firestore document ID
  invoiceNumber: z.string().min(1, "Invoice number is required."),
  clientId: z.string().min(1, "Client selection is required."),
  clientName: z.string().min(1, "Client name is required for the invoice."), 
  clientEmail: z.string().email("Invalid client email for the invoice.").optional().nullable(), 
  issueDate: z.string().refine((date) => !isNaN(new Date(date).getTime()), "Invalid issue date"),
  dueDate: z.string().refine((date) => !isNaN(new Date(date).getTime()), "Invalid due date"),
  items: z.array(InvoiceItemSchema)
    .min(1, "At least one item is required.")
    .max(50, "Maximum 50 items per invoice."),
  subTotalAmount: z.number().min(0, "Subtotal cannot be negative."), // Calculated
  taxAmount: z.number().min(0, "Tax amount cannot be negative.").optional().default(0), // Optional tax
  discountAmount: z.number().min(0, "Discount amount cannot be negative.").optional().default(0), // Optional discount
  totalAmount: z.number().min(0, "Total amount cannot be negative."), // Calculated: subTotal + tax - discount
  status: InvoiceStatusSchema,
  notes: z.string().max(1000, "Notes too long.").optional().nullable(),
  adminId: z.string().min(1, "Admin ID is required."),
  createdAt: z.any().optional(), // Firestore server timestamp
  updatedAt: z.any().optional(), // Firestore server timestamp
  paidAt: z.any().optional().nullable(), // Firestore server timestamp or null
});
export type Invoice = z.infer<typeof InvoiceSchema>;

// Schema for the creation form, omitting fields generated by server or calculated on submission
export const CreateInvoiceFormSchema = InvoiceSchema.omit({
    id: true,
    invoiceNumber: true, // Will be generated by server
    adminId: true, // Will be added by server action
    createdAt: true,
    updatedAt: true,
    paidAt: true,
    subTotalAmount: true, // Will be calculated client-side and validated server-side via totalAmount
    totalAmount: true, // Will be calculated client-side and validated server-side by recalculating
}).extend({
  // For the form, dates can be Date objects before stringifying
  issueDate: z.date({ required_error: "Issue date is required."}),
  dueDate: z.date({ required_error: "Due date is required."}),
});

export type CreateInvoiceFormValues = z.infer<typeof CreateInvoiceFormSchema>;
